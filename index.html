<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>My Learning Journal</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load React and Babel for JSX rendering -->
    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <style>
        /* Load Inter font */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap');
        body { font-family: 'Inter', sans-serif; }
    </style>
</head>
<body>
    <div id="root"></div>

    <!-- The React/JSX Code goes inside a script tag with type="text/babel" -->
    <script type="text/babel">
        const { useState, useEffect } = React;

        // === Blog Post Data ===
        const postsData = [
  {
    id: 1,
    title: "Understanding Django: HTTP Request Lifecycle",
    date: "November 25, 2025",
    tags: ["Django"],
    content: [
      "When you build a Django application, understanding how a browser or client request travels through your Django project is crucial. This guide explains the HTTP request lifecycle, how Django handles it, and the role of WSGI, views, and models.",
      
      "1️⃣ The HTTP Request Lifecycle in Django",
      "Suppose a client (browser or Postman) sends an HTTP request: GET /api/posts/ HTTP/1.1 Host: 127.0.0.1:8000",
      "Here’s what happens step by step:",

      "Step 1: Request arrives at the server",
      "The Django development server (started via 'python manage.py runserver') or a production server like Gunicorn/uWSGI is listening on a TCP port (default is 8000).",
      "The HTTP request travels over TCP/IP from the client to your machine, where it is picked up by the server socket.",
      "Important: The server is just a Python process (or a production server process) listening for incoming network requests.",

      "Step 2: Server passes request to Django (WSGI)",
      "The server calls the WSGI application defined in wsgi.py: application = get_wsgi_application()",
      "WSGI (Web Server Gateway Interface) converts the raw HTTP request into a Python-compatible object called the environ dictionary:",
      "{ 'REQUEST_METHOD': 'GET', 'PATH_INFO': '/api/posts/', 'QUERY_STRING': '', ... }",
      "Now, the request is in a format that Django can understand and process.",
      "Key point: WSGI acts as a bridge between the server process and your Python Django application. Without it, Python wouldn’t understand HTTP requests.",

      "Step 3: Django URL dispatcher routes the request",
      "Django inspects the urls.py files (both project-level and app-level) to determine which view function or class should handle this request.",
      "Example urls.py: path('api/posts/', posts_api)",
      "The request GET /api/posts/ is routed to the posts_api view function.",
      "Important: The URL dispatcher allows you to separate the routing of your project from the actual view logic.",

      "Step 4: View handles the HTTP method",
      "Inside the view function, the view inspects request.method to determine whether it is GET, POST, PUT, DELETE, etc.",
      "It then executes the corresponding logic: fetches data from models, performs business logic, and prepares the response.",
      "Key insight: Views are responsible for processing the request and generating the response, but the server and WSGI handle transport and communication.",

      "Step 5: Response returned via WSGI",
      "The view returns a HttpResponse or JsonResponse object.",
      "WSGI converts this into raw HTTP bytes ready to send back to the client:",
      "HTTP/1.1 200 OK Content-Type: application/json Content-Length: 123 [{\"id\":1,\"title\":\"Hello\"}]",
      "The server sends this back over TCP/IP → the client receives it.",
      "Important: WSGI acts as the bridge in both directions: incoming requests → Python → response → outgoing HTTP.",

      "2️⃣ Key Insight",
      "Every HTTP request (GET, POST, PUT, DELETE) is first converted into a Python-compatible object (request) by WSGI.",
      "Django routes it to the appropriate view, which handles it according to the method.",
      "Finally, WSGI and the server send the response back over the network.",
      "Remember: HTTP requests do not magically go into Django code. They are first received, converted, routed, and then processed.",

      "3️⃣ Conceptual Flow (simplified)",
      "Client (Browser/Postman) → TCP/IP → Server Socket → WSGI → Python request object → Django URL dispatcher → View function → handle GET/POST/PUT/DELETE → fetch models → HttpResponse/JsonResponse → WSGI → TCP/IP → client",

      "4️⃣ TL;DR (In Simple Words)",
      "1. HTTP requests arrive at the server (development or production).",
      "2. WSGI converts raw HTTP into a Python object that Django understands.",
      "3. Django URL dispatcher finds the right view for this request.",
      "4. View handles the request logic and prepares a response.",
      "5. WSGI converts the response into raw HTTP bytes.",
      "6. Server sends the response back to the client.",
      "Golden Rule: WSGI is the translator between the network world (HTTP) and the Python world (Django views).",

      "5️⃣ Extra Notes for Beginners",
      "- Development server ('runserver') is single-threaded and only for testing. Production uses servers like Gunicorn or uWSGI.",
      "- WSGI is a Python standard; all Python web frameworks follow it.",
      "- This lifecycle applies to regular HTML requests as well as REST API calls.",
      "- Models are only involved if your view fetches or modifies data in the database.",

      "6️⃣ Analogy",
      "Think of this like a restaurant:",
      "1. Client → customer placing an order",
      "2. Server → waiter receiving the order",
      "3. WSGI → translator: converts order into kitchen instructions",
      "4. View → chef preparing the meal",
      "5. Model → ingredients and storage (database)",
      "6. Response → waiter brings the meal back to the customer",
      "Everything flows step by step, and each component has a clear responsibility.",

      "✅ Conclusion",
      "Understanding this lifecycle helps you debug, optimize, and design Django applications more effectively. It also shows why Django separates responsibilities: server/transport (WSGI), routing (URL dispatcher), processing (views), and data (models)."
    ],
  },
];

        // Component to display a single blog post
        const BlogPost = ({ post }) => {
          return (
            <div className="bg-white p-6 md:p-8 rounded-xl shadow-lg hover:shadow-xl transition-shadow duration-300 mb-8 border border-gray-100">
              <header className="mb-4 border-b pb-3">
                <h2 className="text-3xl font-extrabold text-gray-900 mb-2 leading-tight">
                  {post.title}
                </h2>
                <p className="text-sm text-indigo-600 font-medium">
                  Published on {post.date}
                </p>
              </header>

              {/* Main Content Area - maps the array of strings to <p> tags */}
              <section className="space-y-5 text-gray-700 leading-relaxed text-lg">
                {post.content.map((paragraph, index) => (
                  <p key={index}>
                    {paragraph}
                  </p>
                ))}
              </section>

              {/* Tags */}
              <footer className="mt-6 pt-4 border-t border-gray-100 flex flex-wrap gap-2">
                {post.tags.map((tag, index) => (
                  <span
                    key={index}
                    className="px-3 py-1 text-xs font-semibold text-indigo-700 bg-indigo-100 rounded-full"
                  >
                    #{tag}
                  </span>
                ))}
              </footer>
            </div>
          );
        };

        // Main App Component
        const App = () => {
          return (
            <div className="min-h-screen bg-gray-50 font-sans antialiased">
              
              {/* Header */}
              <header className="bg-indigo-700 shadow-lg sticky top-0 z-10">
                <div className="max-w-4xl mx-auto py-4 px-4 sm:px-6 lg:px-8">
                  <h1 className="text-2xl md:text-3xl font-bold text-white tracking-tight">
                    My Learning Journal
                  </h1>
                  <p className="text-indigo-200 text-sm mt-1">
                    Documenting my journey one concept at a time.
                  </p>
                </div>
              </header>

              {/* Main Content Area (Blog List) */}
              <main className="max-w-4xl mx-auto py-8 px-4 sm:px-6 lg:px-8">
                <h2 className="text-4xl font-extrabold text-gray-800 mb-10 border-b-4 border-indigo-500 inline-block pb-1">
                  Latest Concepts
                </h2>

                {/* List of Posts */}
                <div className="divide-y divide-gray-200">
                  {postsData.map((post) => (
                    <BlogPost key={post.id} post={post} />
                  ))}
                </div>
                
                {/* Footer */}
                <footer className="mt-12 text-center text-gray-500 text-sm py-4 border-t">
                    <p>&copy; 2025 Learning Journal. Built with React and Tailwind CSS.</p>
                </footer>
              </main>
            </div>
          );
        };

        // Render the App component
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);

    </script>
</body>
</html>