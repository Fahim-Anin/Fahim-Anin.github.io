<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>My Learning Journal</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <style>
        /* Load Inter font */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap');
        body { font-family: 'Inter', sans-serif; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect } = React;

        // Helper component to render content based on type
        const ContentRenderer = ({ contentItem }) => {
            // Added check to ensure text exists to prevent crash
            // Also handles the new question_answer structure
            if (!contentItem || (!contentItem.text && contentItem.type !== 'question_answer')) {
                console.error("ContentRenderer item is missing required properties:", contentItem);
                return null;
            }
            
            const { type, text } = contentItem;

            switch (type) {
                // Major Section Headings (1, 2, 3...)
                case 'h1':
                    return <h2 className="text-3xl font-extrabold text-gray-900 pt-6 mb-4">{text}</h2>;
                case 'h2':
                    return <h3 className="text-2xl font-extrabold text-gray-800 pt-6 mb-3 border-t-2 border-indigo-500 mt-6">{text}</h3>;
                // Step Headings (Step 1, Step 2...)
                case 'h3':
                    return <h4 className="text-xl font-bold text-indigo-700 mt-4 mb-2">{text}</h4>;
                
                // Question/Answer Block (NEW: Added to handle Q/A structure)
                case 'question_answer':
                    return (
                        <div className="p-4 my-4 bg-yellow-50 border-l-4 border-yellow-400 rounded-r-lg shadow-sm">
                            <h4 className="text-xl font-extrabold text-yellow-800 mb-2">Q: {contentItem.question_text}</h4>
                            <p className="text-gray-700 leading-relaxed text-lg">{contentItem.text}</p>
                        </div>
                    );

                // Highlighted HTTP Request Line (Green Banner)
                case 'request':
                    return (
                        <div className="p-3 my-3 bg-green-50 border-l-4 border-green-400 text-green-800 font-mono text-sm overflow-x-auto rounded-r-lg shadow-sm">
                            **HTTP Request:** {text}
                        </div>
                    );
                // Highlighted HTTP Response Line (Red Banner)
                case 'response':
                    return (
                        <div className="p-3 my-3 bg-red-50 border-l-4 border-red-400 text-red-800 font-mono text-sm overflow-x-auto rounded-r-lg shadow-sm">
                            **HTTP Response:** {text}
                        </div>
                    );
                
                // Code Blocks (for Python dictionaries, etc.)
                case 'code_block':
                    return (
                        <pre className="p-3 my-3 bg-gray-100 text-gray-800 font-mono text-sm rounded-lg overflow-x-auto whitespace-pre-wrap shadow-inner">
                            <code>{text}</code>
                        </pre>
                    );
                
                // Flow Diagram (Dark Background)
                case 'flow':
                    return (
                        <div className="p-4 my-4 bg-gray-800 text-white font-mono text-sm rounded-lg shadow-xl overflow-x-auto text-center">
                            <span className="inline-block py-1 px-3 bg-indigo-500 rounded-full text-xs font-bold mr-2">FLOW</span>
                            <span className="block mt-2 text-base">{text}</span>
                        </div>
                    );

                // Important Callouts (Red Border)
                case 'important':
                    return (
                        <p className="text-lg font-semibold text-red-700 border-l-4 border-red-400 pl-4 py-2 my-3 bg-red-50 rounded-r-lg">
                            <span className="font-extrabold mr-1">‚ö†Ô∏è Important:</span> {text}
                        </p>
                    );

                // Key Point Callouts (Blue Border)
                case 'key_point':
                case 'key_insight':
                    return (
                        <p className="text-lg italic text-blue-700 border-l-4 border-blue-400 pl-4 py-2 my-3 bg-blue-50 rounded-r-lg">
                            <span className="font-bold mr-1">üí° Key Insight:</span> {text}
                        </p>
                    );

                // Golden Rule Box (Yellow Box)
                case 'golden_rule':
                    return (
                        <div className="text-center p-4 my-4 bg-yellow-100 border-2 border-yellow-400 rounded-lg shadow-md">
                            <p className="text-xl font-extrabold text-yellow-800">
                                üëë Golden Rule:
                            </p>
                            <p className="text-lg text-yellow-800 mt-1 font-medium">
                                {text}
                            </p>
                        </div>
                    );
                
                // List Items (used for TL;DR and Analogy)
                case 'list':
                    return <li className="ml-5 list-disc text-gray-700 leading-relaxed text-lg">{text}</li>;

                // Conclusion
                case 'conclusion':
                    return (
                        <p className="mt-8 pt-4 border-t-2 border-indigo-500 text-xl font-semibold text-gray-800">
                            {text}
                        </p>
                    );

                // Default Paragraphs
                case 'paragraph':
                default:
                    // Using a simple regex to replace **bold** with <strong> for better styling
                    const formattedText = text.split('**').map((segment, i) => 
                        i % 2 === 1 ? <strong key={i} className="text-gray-900">{segment}</strong> : segment
                    );
                    return <p className="text-gray-700 leading-relaxed text-lg">{formattedText}</p>;
            }
        };


        // === Blog Post Data (Updated to structured format) ===
        const postsData = [
  {
    "id": 1,
    "title": "üöÄ Understanding Django: The HTTP Request Lifecycle ‚Äì WSGI, Middleware, and Views Explained",
    "date": "November 25, 2025",
    "tags": ["Django", "WSGI", "Middleware", "Views", "Web Development"],
    "content": [
      {
        "type": "paragraph",
        "text": "Understanding how a browser request travels through your Django project is the **foundation** of building and debugging robust web applications. This guide details the **HTTP Request Lifecycle**, explaining the critical roles of **WSGI**, **Middleware**, and **Views**."
      },
      {
        "type": "h2",
        "text": "1Ô∏è‚É£ Phase 1: Entry and Translation (The WSGI Bridge)"
      },
      {
        "type": "paragraph",
        "text": "A client (browser, mobile app, or Postman) sends an HTTP Request (e.g., `GET /api/posts/`)."
      },
      {
        "type": "h3",
        "text": "Step 1: Request Arrives at the Server"
      },
      {
        "type": "paragraph",
        "text": "The request travels over **TCP/IP** and is received by your web server software (**Gunicorn** or Django's development server)."
      },
      {
        "type": "key_point",
        "text": "The server's job is simply to listen on a port and hand the raw network data to the application."
      },
      {
        "type": "h3",
        "text": "Step 2: WSGI Translates the Request"
      },
      {
        "type": "paragraph",
        "text": "The server passes the raw HTTP data to the **WSGI (Web Server Gateway Interface)** application, typically defined in `wsgi.py`."
      },
      {
        "type": "important",
        "text": "WSGI acts as a **translator**. It converts the raw HTTP headers and body into a standardized, Python-compatible object called the **`HttpRequest`** object. This is the first thing Django receives."
      },
      {
        "type": "h2",
        "text": "2Ô∏è‚É£ Phase 2: Pre-Processing (The Middleware Layer)"
      },
      {
        "type": "h3",
        "text": "Step 3: Middleware Chain Execution"
      },
      {
        "type": "paragraph",
        "text": "The **`HttpRequest`** object passes through every component in the **Middleware** list (defined in `settings.py`) **before** it reaches the View."
      },
      {
        "type": "list",
        "text": "Middleware handles global tasks like checking if the user is **authenticated** (session and cookies), handling **security** features (CSRF), and managing the request object."
      },
      {
        "type": "key_insight",
        "text": "This allows complex, cross-cutting concerns (like security) to be processed centrally without cluttering every single view function."
      },
      {
        "type": "h2",
        "text": "3Ô∏è‚É£ Phase 3: Routing and Execution"
      },
      {
        "type": "h3",
        "text": "Step 4: URL Dispatcher Routes the Request"
      },
      {
        "type": "paragraph",
        "text": "The request reaches the **URL Dispatcher** (`urls.py`), which matches the URL path (`PATH_INFO`) to the specific **View function or class** responsible for handling it (e.g., `path('api/posts/', posts_api)`)."
      },
      {
        "type": "h3",
        "text": "Step 5: View Handles the Logic"
      },
      {
        "type": "paragraph",
        "text": "The chosen View (in `views.py`) is executed. It inspects **`request.method`** (GET, POST, etc.) and performs the core business logic."
      },
      {
        "type": "paragraph",
        "text": "If data is involved, the View interacts with the **ORM** to query or save **Models** (`models.py`)."
      },
      {
        "type": "h2",
        "text": "4Ô∏è‚É£ Phase 4: Response Generation and Return Trip"
      },
      {
        "type": "h3",
        "text": "Step 6: Response Passes Through Middleware"
      },
      {
        "type": "paragraph",
        "text": "The View returns an **`HttpResponse`** object (e.g., a rendered template or JSON data). This response object travels **back** through the Middleware chain (in reverse order) for final processing (e.g., saving session updates)."
      },
      {
        "type": "h3",
        "text": "Step 7: WSGI Re-translates and Server Sends"
      },
      {
        "type": "paragraph",
        "text": "WSGI converts the final Python `HttpResponse` object back into a raw HTTP response ready for network transmission."
      },
      {
        "type": "response",
        "text": "HTTP/1.1 200 OK Content-Type: application/json [JSON payload...]"
      },
      {
        "type": "paragraph",
        "text": "The server sends the response over **TCP/IP** to the client, completing the cycle."
      },
      {
        "type": "flow",
        "text": "Client ‚Üí TCP/IP ‚Üí Server ‚Üí WSGI ‚Üí Request Middleware ‚Üí URL Dispatcher ‚Üí View/Logic ‚Üí ORM/Models ‚Üí Response Middleware ‚Üí WSGI ‚Üí TCP/IP ‚Üí Client"
      },
      {
        "type": "conclusion",
        "text": "‚úÖ **Conclusion:** The Django lifecycle is a pipeline where each component has a single, well-defined job. **WSGI** handles the network/Python bridge, **Middleware** handles global request processing, and the **View** handles the core application logic."
      }
    ],
  },
  {
    "id": 2,
    "title": "üß± Django Models & Migrations: The ORM Core Explained for Beginners",
    "date": "November 28, 2025",
    "tags": ["Django", "Models", "Migrations", "ORM", "Database"],
    "content": [
      {
        "type": "paragraph",
        "text": "**Models** and **Migrations** form the backbone of Django's **ORM (Object-Relational Mapping)**. This system allows you to interact with your database using easy-to-read Python code, entirely avoiding raw SQL."
      },
      {
        "type": "h2",
        "text": "1Ô∏è‚É£ Django Models: The Database Blueprint"
      },
      {
        "type": "h3",
        "text": "What Happens When You Write `models.Model`?"
      },
      {
        "type": "code_block",
        "text": "class Student(models.Model):\n    name = models.CharField(max_length=100)\n    age = models.IntegerField()"
      },
      {
        "type": "paragraph",
        "text": "By inheriting from `models.Model`, your Python class is transformed into a database blueprint by the ORM."
      },
      {
        "type": "list",
        "text": "The class maps directly to a **Table** (e.g., `appname_student`)."
      },
      {
        "type": "list",
        "text": "Fields (`CharField`, `IntegerField`) become **Columns** (e.g., `VARCHAR(100)`, `INTEGER`)."
      },
      {
        "type": "list",
        "text": "Django automatically adds a primary key **`id`** column and the **Model Manager** (`.objects`)."
      },
      {
        "type": "key_insight",
        "text": "The ORM allows you to use Python code like `Student.objects.filter(age__gt=18)` which is translated into efficient SQL without manual effort."
      },
      {
        "type": "h2",
        "text": "2Ô∏è‚É£ Migrations: Database Version Control"
      },
      {
        "type": "paragraph",
        "text": "Migrations are Django‚Äôs official system for applying changes from your **Python Models** to your **actual database schema**."
      },
      {
        "type": "h3",
        "text": "Step 1: Creating the Change Plan (`makemigrations`)"
      },
      {
        "type": "code_block",
        "text": "python manage.py makemigrations"
      },
      {
        "type": "paragraph",
        "text": "This command compares your current `models.py` against the last state and writes a new, numbered Python file in the `migrations/` folder (e.g., `0002_add_email_to_student.py`). This file contains the **instructions** for the database change (the plan)."
      },
      {
        "type": "h3",
        "text": "Step 2: Applying the Change (`migrate`)"
      },
      {
        "type": "code_block",
        "text": "python manage.py migrate"
      },
      {
        "type": "paragraph",
        "text": "This command reads the migration files. The ORM translates the Python instructions into the correct **SQL queries** for your database (e.g., `ALTER TABLE app_student ADD COLUMN email...`). It then executes this SQL."
      },
      {
        "type": "important",
        "text": "Your database schema is **NOT** changed until you run the `migrate` command. Migrations provide a crucial, reversible history of all your database changes."
      },
      {
        "type": "flow",
        "text": "models.py (New Blueprint) ‚Üí makemigrations (Create Python Plan) ‚Üí migrate (Execute SQL Plan) ‚Üí Database Schema Updated"
      },
      {
        "type": "conclusion",
        "text": "‚úÖ **Conclusion:** **Models** define the structure in Python. **Migrations** are the tools that safely transfer and manage that structure in the live database. The **ORM** is the engine driving both processes."
      }
    ],
  },
  {
    "id": 3,
    "title": "üõ°Ô∏è Understanding Django Admin: The Two-Line Database Manager",
    "date": "December 6, 2025",
    "tags": ["Django", "Admin", "Database", "CRUD"],
    "content": [
      {
        "type": "paragraph",
        "text": "The Django Admin is a powerful, automatically-generated interface that allows developers and content managers to perform **CRUD** (Create, Read, Update, Delete) operations on database records without writing any HTML, CSS, or complex SQL."
      },
      {
        "type": "h2",
        "text": "1Ô∏è‚É£ The Two Essential Lines in `admin.py`"
      },
      {
        "type": "code_block",
        "text": "from .models import Destination\nfrom django.contrib import admin\n\nadmin.site.register(Destination)"
      },
      {
        "type": "list",
        "text": "The **`import`** tells `admin.py` which model to manage."
      },
      {
        "type": "list",
        "text": "The **`register()`** method tells the Django Admin application to automatically generate all the necessary forms, views, validation, and URLs needed for CRUD operations on the `Destination` Model."
      },
      {
        "type": "h2",
        "text": "2Ô∏è‚É£ Internal Flow When Saving Data in Admin"
      },
      {
        "type": "paragraph",
        "text": "When you fill out a form in the Admin Panel and click 'Save', a simplified request-response cycle occurs:"
      },
      {
        "type": "h3",
        "text": "Step 1: Admin View Validation"
      },
      {
        "type": "paragraph",
        "text": "The Admin view receives the form data (a POST request) and uses the Model‚Äôs field definitions (e.g., `max_length`) to validate the input."
      },
      {
        "type": "h3",
        "text": "Step 2: Model Instance Creation"
      },
      {
        "type": "paragraph",
        "text": "The Admin view creates an in-memory **Model Instance** from the validated data (e.g., `destination = Destination(name='Paris', ...)`)."
      },
      {
        "type": "h3",
        "text": "Step 3: ORM Translates and Executes"
      },
      {
        "type": "paragraph",
        "text": "The Admin calls `destination.save()`. The **ORM** takes over, translating the Python object into a specific SQL query based on your database configuration (e.g., `INSERT INTO app_destination...`)."
      },
      {
        "type": "code_block",
        "text": "INSERT INTO yourapp_destination (name, description) VALUES ('Paris', 'Beautiful city');"
      },
      {
        "type": "h3",
        "text": "Step 4: Database Commits the Record"
      },
      {
        "type": "paragraph",
        "text": "The database executes the SQL, assigns an automatic `id`, and permanently stores the record."
      },
      {
        "type": "flow",
        "text": "Admin Form Submit ‚Üí Admin View ‚Üí Model Instance ‚Üí ORM ‚Üí SQL Query ‚Üí Database Save ‚Üí Auto ID Assigned ‚Üí Admin Confirmation"
      },
      {
        "type": "important",
        "text": "The Admin site abstracts the database entirely. It knows how to manage data solely because of the **Model** defined in `models.py` and the power of the **ORM**."
      },
      {
        "type": "conclusion",
        "text": "‚úÖ **Conclusion:** Django Admin is a highly leveraged feature. With minimal code, it uses the core **Model** definitions and the **ORM** to deliver a complete database management interface, saving developers significant time."
      }
    ],
  },
               
  {
    "id": 4,
    "title": "üîê From Submit to Save: The Full Journey of Data, Password Hashing, and User Auth in Django",
    "date": "December 7, 2025",
    "tags": ["Django", "ORM", "Authentication", "Database", "Security", "Web Development"],
    "content": [
      {
        "type": "h1",
        "text": "üöÄ From Submit Button to Database: The Full Journey of Your Data in Django"
      },
      {
        "type": "paragraph",
        "text": "Understanding how your data travels from a browser form, through Django's security systems (like **password hashing**), and into the database is essential. This guide explains the exact **step-by-step flow** for data submission, focusing on user creation and login."
      },
      {
        "type": "h2",
        "text": "üîç Core Authentication Components"
      },
      {
        "type": "paragraph",
        "text": "The Django Authentication system is built around these core components:"
      },
      {
        "type": "code_block",
        "text": "from django.contrib.auth.models import User\nfrom django.contrib import auth"
      },
      {
        "type": "list",
        "text": "**`User` Model:** The ORM blueprint that maps directly to the `auth_user` table. It holds the username, email, and the **hashed** password."
      },
      {
        "type": "list",
        "text": "**`auth` Module:** Provides the core functions: **`authenticate()`** (checks credentials), **`login()`** (starts the session), and **`logout()`** (ends the session)."
      },
      {
        "type": "h2",
        "text": "1Ô∏è‚É£ Data Submission and Routing (Steps 1-3)"
      },
      {
        "type": "h3",
        "text": "Step 1: Browser Sends POST Request"
      },
      {
        "type": "paragraph",
        "text": "The client bundles the form data (e.g., username, plaintext password) and sends it as an **HTTP POST request** to the designated URL (e.g., `/register/`)."
      },
      {
        "type": "h3",
        "text": "Step 2 & 3: Django Parses and Routes"
      },
      {
        "type": "paragraph",
        "text": "The request is processed by WSGI and Middleware, then the **URL Dispatcher** finds the correct View. Inside the View, data is extracted from the request object."
      },
      {
        "type": "code_block",
        "text": "def register_user(request):\n    # Data extracted as plain text strings\n    username = request.POST.get('username')\n    password = request.POST.get('password')"
      },
      {
        "type": "h2",
        "text": "2Ô∏è‚É£ Data Security: The Hashing Process (Steps 4-6)"
      },
      {
        "type": "h3",
        "text": "Step 4: Creating the Python Model Instance"
      },
      {
        "type": "code_block",
        "text": "# Object is created in memory, but NOT saved to DB yet.\nuser = User(username=username)"
      },
      {
        "type": "h3",
        "text": "Step 5: Mandatory Password Hashing"
      },
      {
        "type": "paragraph",
        "text": "**Django NEVER stores plaintext passwords.** This is a non-negotiable security requirement. The process is handled by a special method:"
      },
      {
        "type": "code_block",
        "text": "# Calls Django's make_password() utility internally.\nuser.set_password(password)"
      },
      {
        "type": "key_insight",
        "text": "Django uses strong, modern hashing algorithms like **PBKDF2 with SHA256**. Hashing is a one-way process; the original password cannot be recovered, ensuring security even if the database is compromised."
      },
      {
        "type": "h3",
        "text": "Step 6: ORM Converts to SQL"
      },
      {
        "type": "paragraph",
        "text": "Calling `user.save()` triggers the ORM to convert the in-memory Python object into a validated SQL `INSERT` statement, with the password stored as the complex hashed string (e.g., `pbkdf2_sha256$........`)."
      },
      {
        "type": "h2",
        "text": "3Ô∏è‚É£ Database Commitment and Response (Steps 7-9)"
      },
      {
        "type": "h3",
        "text": "Step 7: Database Connection and Save"
      },
      {
        "type": "paragraph",
        "text": "Using credentials from `settings.py`, the ORM executes the SQL query. The database stores the new user record, assigns a unique **Primary Key ID**, and enforces constraints (like unique usernames)."
      },
      {
        "type": "important",
        "text": "Django automatically manages the connection lifecycle (open, transaction, commit, close) for every request, abstracting the complexity from the developer."
      },
      {
        "type": "h3",
        "text": "Step 8 & 9: Returning the HTTP Response"
      },
      {
        "type": "paragraph",
        "text": "The View finishes its logic and returns an `HttpResponse` (often a redirect to the login page), completing the cycle."
      },
      {
        "type": "flow",
        "text": "Browser POST ‚Üí Django View ‚Üí User Object (In Memory) ‚Üí set_password() (HASHING) ‚Üí user.save() ‚Üí ORM (SQL INSERT) ‚Üí Database ‚Üí Response"
      },
      {
        "type": "h2",
        "text": "üî• How Login Works Internally (Authentication and Session)"
      },
      {
        "type": "paragraph",
        "text": "Login uses a similar flow but involves verification instead of saving."
      },
      {
        "type": "h3",
        "text": "Core Function: `auth.authenticate()`"
      },
      {
        "type": "code_block",
        "text": "user = auth.authenticate(request, username=username, password=password)"
      },
      {
        "type": "list",
        "text": "1. **Fetch:** Django retrieves the stored **hashed password** for the given username from the database."
      },
      {
        "type": "list",
        "text": "2. **Re-Hash & Compare:** It hashes the **plaintext password** submitted by the user and compares the new hash to the stored hash. If they match, authentication is successful."
      },
      {
        "type": "h3",
        "text": "Session Creation: `auth.login()`"
      },
      {
        "type": "code_block",
        "text": "auth.login(request, user)"
      },
      {
        "type": "paragraph",
        "text": "This function is crucial: it starts a new **session** for the user and stores the user's Primary Key ID in that session. A **session cookie** is sent to the browser, linking future requests to that authenticated session."
      },
      {
        "type": "conclusion",
        "text": "üéâ **Conclusion:** Django's Auth system is a masterpiece of abstraction and security. It guarantees plaintext passwords never touch the database and uses robust session management to maintain user state across requests, all while simplifying the code you have to write."
      }
    ],
  },
  {
    "id": 5,
    "title": "üëÅÔ∏è‚Äçüó®Ô∏è How Django Checks Username Availability and Displays Messages (ORM & Session Flow)",
    "date": "December 7, 2025",
    "tags": ["Django", "ORM", "Database", "Messages", "User Authentication", "Session"],
    "content": [
      {
        "type": "h1",
        "text": "üîç How Django Checks Usernames and Shows Messages: Step-by-Step Internal Flow"
      },
      {
        "type": "paragraph",
        "text": "This guide breaks down two key concepts: the **most efficient way to query the database** for username availability, and the internal mechanics of the **Django Messages Framework**."
      },
      {
        "type": "h2",
        "text": "1Ô∏è‚É£ Efficient Database Check: The `.exists()` Method"
      },
      {
        "type": "h3",
        "text": "The Python Code You Write"
      },
      {
        "type": "code_block",
        "text": "if User.objects.filter(username=username).exists():"
      },
      {
        "type": "paragraph",
        "text": "The Django ORM is designed for efficiency. This query is superior to using `.count() > 0` or `.get()`, especially for large datasets."
      },
      {
        "type": "list",
        "text": "**`filter(username=username)`:** Creates a **QuerySet** object. This action is **lazy** (no database hit yet)."
      },
      {
        "type": "list",
        "text": "**`.exists()`:** The method that finally executes the query against the database."
      },
      {
        "type": "key_insight",
        "text": "By adding `LIMIT 1`, the database avoids scanning the entire table, making this check extremely fast. The result is converted simply to a Python `True` or `False`."
      },
      {
        "type": "h2",
        "text": "2Ô∏è‚É£ The Messages Framework: Surviving a Redirect"
      },
      {
        "type": "paragraph",
        "text": "If the username is taken, you need to show an error message on the *next* page. This is handled by the **Messages Framework** and the concept of **PRG (Post-Redirect-Get)**."
      },
      {
        "type": "h3",
        "text": "Phase A: Saving the Message"
      },
      {
        "type": "code_block",
        "text": "messages.info(request, 'Username is taken')\nreturn redirect('/register')"
      },
      {
        "type": "list",
        "text": "1. **Message Storage:** `messages.info()` stores the message text and its level (`INFO`, `ERROR`, etc.) into the user's **Session** (or cookie). This is crucial because session data persists across multiple requests."
      },
      {
        "type": "list",
        "text": "2. **Redirect:** `redirect('/register')` sends an **HTTP 302** status code. The browser is instructed to immediately send a new **GET** request to the `/register` URL."
      },
      {
        "type": "h3",
        "text": "Phase B: Displaying and Consuming the Message"
      },
      {
        "type": "list",
        "text": "3. **New GET Request:** The browser loads the registration page again."
      },
      {
        "type": "list",
        "text": "4. **Middleware Action:** The **`MessageMiddleware`** intercepts this request, finds the stored messages in the session, and attaches them to the `request` object's **context**."
      },
      {
        "type": "list",
        "text": "5. **Template Rendering:** The template code (`{% for message in messages %}`) loops through the messages provided by the Middleware and renders them as HTML."
      },
      {
        "type": "list",
        "text": "6. **Consumption:** Immediately after the messages are pulled for rendering, the MessageMiddleware automatically **deletes** them from the session, ensuring they only appear once."
      },
      {
        "type": "important",
        "text": "The PRG pattern prevents the user from accidentally submitting the form twice if they refresh the page (which would cause a duplicate username error)."
      },
      {
        "type": "flow",
        "text": "User POST ‚Üí View (Check DB) ‚Üí Save Message to SESSION ‚Üí Redirect (HTTP 302) ‚Üí Browser GET ‚Üí MessageMiddleware (Attach to Context) ‚Üí Template (Display) ‚Üí Message Removed from SESSION"
      },
      {
        "type": "h2",
        "text": "3Ô∏è‚É£ Analogy: The Sticky Note"
      },
      {
        "type": "paragraph",
        "text": "The session acts like a **Sticky Note** attached to the user. When an error occurs, the message is written on the note and stuck to the user's session. The redirect takes the user to a new page, but the sticky note (session) travels with them. The new page reads the note, displays the message, and immediately throws the note away so it doesn't show up again."
      },
      {
        "type": "conclusion",
        "text": "‚úÖ **Conclusion:** The combination of the **ORM's optimized querying** and the **Messages Framework's session-based delivery** provides a secure, efficient, and user-friendly way to handle form validation and communicate state changes in Django."
      }
    ],
  },
  {
    "id": 6,
    "title": "Django Auth & Login: How `authenticate()` and `login()` Work Behind the Scenes",
    "date": "December 7, 2025",
    "tags": ["Django", "Authentication", "Login", "Session", "ORM"],
    "content": [
      {
        "type": "paragraph",
        "text": "Logging in a user in Django might seem like magic, but behind the scenes, a lot happens ‚Äî from your browser sending the request to Django validating credentials and creating a session. In this blog, we‚Äôll explore everything about `auth`, `authenticate()`, and `login()` step by step."
      },
      {
        "type": "h2",
        "text": "1Ô∏è‚É£ What is `auth` in Django?"
      },
      {
        "type": "paragraph",
        "text": "`auth` is Django‚Äôs built-in authentication framework (`django.contrib.auth`). It handles user login, logout, password hashing, sessions, and permissions."
      },
      {
        "type": "list",
        "text": "**User Model** ‚Üí stores username, email, hashed password, and permissions"
      },
      {
        "type": "list",
        "text": "**Authentication Functions** ‚Üí `authenticate()`, `login()`, `logout()`"
      },
      {
        "type": "list",
        "text": "**Password Management** ‚Üí `set_password()` hashes passwords securely, `check_password()` validates them"
      },
      {
        "type": "list",
        "text": "**Sessions** ‚Üí keeps users logged in across requests"
      },
      {
        "type": "list",
        "text": "**Permissions & Groups** ‚Üí controls access and roles"
      },
      {
        "type": "h2",
        "text": "2Ô∏è‚É£ Why `auth` is important"
      },
      {
        "type": "paragraph",
        "text": "It ensures security, saves time, integrates with sessions, and provides a standard API."
      }
    ]
  },
  {
    "id": 7,
    "title": "REST API Fundamentals: Serialization, Deserialization, and Validation",
    "date": "December 8, 2025",
    "tags": ["Django", "DRF", "API", "Serialization", "Validation", "JSON"],
    "content": [
      {
        "type": "h1",
        "text": "REST API Fundamentals: Serialization, Deserialization, and Validation in Django"
      },
      {
        "type": "paragraph",
        "text": "When building an API with Django, specifically using Django REST Framework (DRF), the **Serializer** is the most crucial component. It acts as the necessary translator between the Django application (Python objects/Models) and the client (JSON data)."
      },
      {
        "type": "h2",
        "text": "1Ô∏è‚É£ Serialization: Python Object ‚Üí JSON"
      },
      {
        "type": "paragraph",
        "text": "The core job of serialization is to convert complex Python objects (like Django **Model instances** or **QuerySets**) into native Python datatypes (**dictionaries/lists of dictionaries**) that can be easily rendered into JSON, XML, or other content types understood by the client."
      },
      {
        "type": "code_block",
        "text": "qs = Destination.objects.all()\nserializer = DestinationSerializer(qs, many=True)\nprint(serializer.data)\n# Output: A Python List of Dictionaries"
      },
      {
        "type": "list",
        "text": "Without serialization: Django objects contain internal references, date formats, and foreign key connections that cannot be directly sent over HTTP."
      },
      {
        "type": "list",
        "text": "With serialization: Data is converted to a universal format. For example, a `datetime` object becomes a simple, standardized string."
      },
      {
        "type": "h2",
        "text": "2Ô∏è‚É£ Deserialization: JSON ‚Üí Python Object"
      },
      {
        "type": "paragraph",
        "text": "When a client sends data (e.g., a POST request to create a new record), the process is reversed. Deserialization takes the incoming raw data (usually JSON), converts it into a Python dictionary, validates the fields, and then allows it to be used to create or update a Django Model instance."
      },
      {
        "type": "code_block",
        "text": "serializer = DestinationSerializer(data=request.data)\nif serializer.is_valid():\n    instance = serializer.save()\n    # instance is now a Django Model object"
      },
      {
        "type": "h2",
        "text": "3Ô∏è‚É£ Validation: The Essential Gatekeeper"
      },
      {
        "type": "paragraph",
        "text": "Validation is automatically triggered when you call `serializer.is_valid()` on input data. The serializer checks the incoming data against the rules defined in its fields and the Model's constraints."
      },
      {
        "type": "list",
        "text": "Checks required fields, types, formats"
      },
      {
        "type": "list",
        "text": "Runs custom `validate_...` methods"
      },
      {
        "type": "list",
        "text": "Prevents invalid or malicious data from reaching your models"
      },
      {
        "type": "code_block",
        "text": "# Example serializer (DRF)\nfrom rest_framework import serializers\nfrom .models import Destination\n\nclass DestinationSerializer(serializers.ModelSerializer):\n    class Meta:\n        model = Destination\n        fields = ['id','name','price','offer','img']"
      },
      {
        "type": "h2",
        "text": "5Ô∏è‚É£ Who Calls the Serializer? ‚Äî The Full Request Flow"
      },
      {
        "type": "paragraph",
        "text": "When a browser or client makes an HTTP request to an API endpoint, here's the typical chain (Django + Django REST Framework):"
      },
      {
        "type": "list",
        "text": "Client (Browser/React/Mobile) ‚Üí HTTP Request"
      },
      {
        "type": "list",
        "text": "Web server / WSGI ‚Üí turns raw HTTP into Django HttpRequest"
      },
      {
        "type": "list",
        "text": "URL dispatcher ‚Üí finds the API view (APIView / ViewSet / function view)"
      },
      {
        "type": "list",
        "text": "**The view** calls the **serializer** to convert data to/from Python or to validate input"
      },
      {
        "type": "list",
        "text": "Serializer returns primitive data ‚Üí View returns a Response object ‚Üí The REST renderer (JSONRenderer) converts it to JSON bytes ‚Üí WSGI sends JSON to client"
      },
      {
        "type": "h3",
        "text": "Flow (concise)"
      },
      {
        "type": "flow",
        "text": "Client ‚Üí WSGI ‚Üí URL resolver ‚Üí View ‚Üí Serializer ‚Üí Response ‚Üí Renderer ‚Üí Client"
      },
      {
        "type": "conclusion",
        "text": "‚úÖ **Conclusion:** The serializer is the **bridge** of your API, ensuring data is transferred securely and correctly between the client (JSON) and your Django application (ORM/Models)."
      }
    ],
  },
  {
    "id": 8,
    "title": "Mastering Serializers & API Flow: The Complete Django REST Guide",
    "date": "December 9, 2025",
    "tags": ["Django", "DRF", "API-Flow", "Serialization", "Deserialization"],
    "content": [
      {
        "type": "h1",
        "text": "Mastering Serializers & API Flow: The Complete Django REST Guide"
      },
      {
        "type": "paragraph",
        "text": "This guide consolidates the entire process of how a request flows through a Django REST Framework (DRF) application, focusing heavily on the pivotal role of the **Serializer**. It breaks down every file, line of code, and internal step."
      },
      {
        "type": "h2",
        "text": "1Ô∏è‚É£ The Full Request Flow (Read/GET)"
      },
      {
        "type": "paragraph",
        "text": "Here is the complete chain of events when a client sends a request (e.g., fetching all snippets):"
      },
      {
        "type": "list",
        "text": "1. **Client Request** $\rightarrow$ User sends HTTP request to `/snippets/`."
      },
      {
        "type": "list",
        "text": "2. **Root `urls.py`** $\rightarrow$ Matches `path(\"\", include(\"snippets.urls\"))` and redirects to the app's URL file."
      },
      {
        "type": "list",
        "text": "3. **App `snippets/urls.py`** $\rightarrow$ Matches `path(\"snippets/\", views.snippet_list)` and calls the specific view function."
      },
      {
        "type": "list",
        "text": "4. **View (`views.py`)** $\rightarrow$ Detects the HTTP method (`GET` or `POST`)."
      },
      {
        "type": "list",
        "text": "5. **Data Handling (Serialization/Deserialization)** $\rightarrow$ The view uses the **Serializer** to interact with the **Model** to read/write data from/to the **Database**."
      },
      {
        "type": "list",
        "text": "6. **Response** $\rightarrow$ The view returns a `JsonResponse` with the serialized data to the client."
      },
      {
        "type": "h2",
        "text": "2Ô∏è‚É£ The Deserialization (Write/POST) Flow"
      },
      {
        "type": "h3",
        "text": "Phase 1: Validation and Cleaning"
      },
      {
        "type": "code_block",
        "text": "# POST Request Flow (Inside views.py)\nelif request.method == \"POST\":\n data = JSONParser().parse(request) # 1. Deserialize raw JSON to Python Dict\n serializer = SnippetSerializer(data=data) # 2. Initialize with input data\n if serializer.is_valid(): # 3. Trigger validation checks\n  serializer.save() # 4. Saves the data to the DB\n  return JsonResponse(serializer.data, status=201)\n return JsonResponse(serializer.errors, status=400)"
      },
      {
        "type": "list",
        "text": "1. **`JSONParser().parse(request)`:** DRF takes the raw request body (the JSON string) and converts it into a Python dictionary (`data`). This is the first step of **Deserialization**."
      },
      {
        "type": "list",
        "text": "2. **`serializer.is_valid()`:** This is the **Validation** step. If data fails, `is_valid()` returns `False`, and `serializer.errors` holds the messages."
      },
      {
        "type": "h3",
        "text": "Phase 2: The `serializer.save()` and `create()` Flow"
      },
      {
        "type": "paragraph",
        "text": "The magic is in the `save()` method, which decides whether to create a new object or update an existing one."
      },
      {
        "type": "list",
        "text": "**Logic:** Because the serializer was initialized **only with data** (`SnippetSerializer(data=data)`) and *without* an existing model instance, the internal `save()` logic determines it must be a **creation** request."
      },
      {
        "type": "list",
        "text": "**Call:** `save()` then executes the **`create()`** method, passing the clean data: `self.create(validated_data)`."
      },
      {
        "type": "code_block",
        "text": "# Inside serializers.py (the create method is executed):\ndef create(self, validated_data):\n # validated_data is the clean Python dictionary \n return Snippet.objects.create(**validated_data) # DB INSERT: ** unpacked dictionary is passed to the ORM, creating a new row."
      },
      {
        "type": "conclusion",
        "text": "‚úÖ **Conclusion:** DRF views handle routing and HTTP methods. The Serializer handles the crucial steps of **Parsing/Conversion** (JSON to Dict), **Validation** (checking rules), and **Persistence** (`.save()` to the ORM/DB)."
      }
    ]
  },
        {
    "id": 9,
    "title": "Deciphering Class-Based Views: The APIView, as_view(), and Dispatch Flow",
    "date": "December 10, 2025",
    "tags": ["Django", "DRF", "API-Flow", "Serialization", "Deserialization"],
    "content": [
        { "type": "paragraph", "text": "This guide breaks down the core mechanism of how Django REST Framework (DRF) converts an HTTP Request into a Python Class Method call using the **`APIView`** and its key helper methods. Understanding this flow is the key to mastering DRF." },

        { "type": "h2", "üí° Core Concept Analogy: The Automated Mailroom" },
        { "type": "paragraph", "text": "The CBV process is like an automated mailroom that routes messages to the correct department manager:" },
        { "type": "list", "text": "**`SnippetList` (Your Class):** The **Department** (A collection of methods for handling different tasks: GET, POST)."},
        { "type": "list", "text": "**`as_view()`:** The **Mailroom Attendant** (The only person the post office/Django knows; converts the department into an addressable entity)."},
        { "type": "list", "text": "**`dispatch()`:** The **Sorting Machine** (Reads the 'type' of the incoming mail/HTTP method and routes it to the correct internal method)."},
        { "type": "list", "text": "**`def get`/`def post`:** The **Department Managers** (The specific functions that handle the actual work)."},

        { "type": "h2", "üîó The URL to View Mapping (Simplified & Focused)" },
        { "type": "code_block", "text": "path(\"snippets/\", views.SnippetList.as_view())," },
        { "type": "paragraph", "text": "The key question is: **Where is the object?** The answer lies in the **`as_view()`** class method:" },
        { "type": "list", "text": "1. **The Requirement:** Django‚Äôs URL resolver is designed to call a **function** (a callable). It cannot directly call a Python **Class** (`SnippetList`)."},
        { "type": "list", "text": "2. **The Bridge (`as_view()`):** This is a special `classmethod` that is executed **when Django starts up** and reads `urls.py`. It does **not** create the `SnippetList` object yet."},
        { "type": "list", "text": "3. **What it Returns:** It returns a special **wrapper function** that meets Django's requirement. This function is what Django stores in its URL map."},
        { "type": "list", "text": "4. **Object Creation (Runtime):** Only **when an HTTP request for `/snippets/` arrives**, Django calls the wrapper function. This function then **instantiates** the `SnippetList` class (creating the object) and immediately calls the object's `dispatch()` method. **The object is created dynamically at request time.**"},

        { "type": "h2", "üîÑ The Full CBV Request-Response Cycle" },
        { "type": "paragraph", "text": "This shows the complete chain from the client request to the method call." },
        

        { "type": "list", "text": "1. **Client Request:** An HTTP request (e.g., `GET /snippets/`) arrives at the server."},
        { "type": "list", "text": "2. **URL Matching:** Django‚Äôs URL resolver finds the entry for `/snippets/` and identifies the wrapper function returned by `SnippetList.as_view()`."},
        { "type": "list", "text": "3. **Class Instantiation:** The wrapper function executes: **`view_instance = SnippetList()`**."},
        { "type": "list", "text": "4. **Dispatch:** The wrapper function calls the core entry point: **`view_instance.dispatch(request, *args, **kwargs)`**."},
        { "type": "list", "text": "5. **Method Routing (The Switch):** The `dispatch()` method inside `APIView` reads the HTTP verb from the `request` object (`request.method`)."},
        { "type": "list", "text": "6. **Method Call:** Based on the verb (e.g., 'GET'), `dispatch()` dynamically calls the corresponding method on the instance: **`view_instance.get(request, format=None)`**."},
        { "type": "list", "text": "7. **Execution:** Your overridden `get()` method runs, performs database/serializer logic, and returns a `Response` object."},
        { "type": "list", "text": "8. **Response:** The response is packaged and sent back to the client."},
        
        { "type": "h2", "üî¨ Method Overriding and The `dispatch()` Magic" },
        
        { "type": "paragraph", "text": "The magic of Class-Based Views is achieved through **Method Overriding** and the powerful **`dispatch`** method from the parent `APIView` class." },
        
        { "type": "h3", "text": "Method Overriding" },
        { "type": "paragraph", "text": "By defining methods like `get`, `post`, `put`, etc., in your `SnippetList` class, you are **overriding** the methods of the same name that exist in the base `APIView`. You only implement the business logic you care about." },
        
        { "type": "h3", "text": "The `dispatch()` Method" },
        { "type": "paragraph", "text": "This is the central router. It takes the incoming request and hands it off to the correct method. It looks something like this (simplified):" },
        { "type": "code_block", "text": "# Simplified logic of APIView's dispatch method\n\ndef dispatch(self, request, *args, **kwargs):\n    http_method = request.method.lower() # e.g., 'get', 'post'\n    \n    # 1. Look up the method on the view instance\n    if hasattr(self, http_method):\n        handler = getattr(self, http_method) # Gets the actual function (self.get or self.post)\n        \n        # 2. Call the found method with the request data\n        response = handler(request, *args, **kwargs)\n        return response\n    \n    # If no method is found (e.g., a request method 'TRACE')\n    return self.http_method_not_allowed(request, *args, **kwargs)" },
        { "type": "paragraph", "text": "**Crucially, it calls your implemented method: `handler(request, *args, **kwargs)`**." },

        { "type": "h2", "üéöÔ∏è Understanding the Method Parameters" },
        { "type": "code_block", "text": "def get(self, request, format=None):" },
        
        { "type": "h3", "text": "1. `self`" },
        { "type": "list", "text": "**Purpose:** Standard Python instance reference. It is the specific `SnippetList` object created for handling this one request. It allows the method to access class attributes and other methods (though typically views are stateless)."},
        
        { "type": "h3", "text": "2. `request`" },
        { "type": "list", "text": "**Purpose:** An instance of **`rest_framework.request.Request`**. This is a powerful wrapper around the standard Django `HttpRequest`."},
        { "type": "list", "text": "**Why it's needed:** It provides easy access to the parsed request body, regardless of format (JSON, XML, Form Data) via **`request.data`**. It also holds query parameters, headers, and the authenticated user."},
        
        { "type": "h3", "text": "3. `format=None`" },
        { "type": "list", "text": "**Purpose:** Handles URL format suffixes, enabled by `format_suffix_patterns` in your `urls.py`."},
        { "type": "list", "text": "**Why it's needed:** If a client requests `/snippets.json`, DRF detects the `.json` suffix, sets `format='json'`, and passes it here. This allows the view to potentially alter its behavior or rendering based on the requested format."},
        
        { "type": "h2", "üéØ Example Flow: GET vs. POST Request" },
        
        { "type": "h3", "text": "Example 1: GET Request (Listing Snippets)" },
        { "type": "list", "text": "**Client:** Sends `GET /snippets/`."},
        { "type": "list", "text": "**`dispatch()`:** Sees `request.method == 'GET'` and calls **`instance.get(request, format=None)`**."},
        { "type": "list", "text": "**Your Code:** `get` runs, fetches objects (`Snippet.objects.all()`), serializes them, and returns `Response(serializer.data)`."},
        { "type": "list", "text": "**Output:** HTTP 200 OK with a list of JSON objects."},

        { "type": "h3", "text": "Example 2: POST Request (Creating a Snippet)" },
        { "type": "list", "text": "**Client:** Sends `POST /snippets/` with JSON data in the body."},
        { "type": "list", "text": "**`dispatch()`:** Sees `request.method == 'POST'` and calls **`instance.post(request, format=None)`**."},
        { "type": "list", "text": "**Your Code:** `post` runs. It accesses input data via **`request.data`** (automatically parsed from JSON). It validates and saves the new object."},
        { "type": "list", "text": "**Output:** HTTP 201 Created with the full JSON object (including the new `id`)."}
    ]
},  
            
  {
    "id": 10,
    "title": "Java Fundamentals: JVM, JRE, JDK, and the Main Method",
    "date": "December 10, 2025",
    "tags": ["Java", "JVM", "JRE", "JDK", "Fundamentals"],
    "content": [
      {
        "type": "paragraph",
        "text": "To run any Java program, you need to understand the fundamental components of the Java ecosystem. These three components‚Äî**JVM, JRE, and JDK**‚Äîare commonly misunderstood but are crucial for developing and executing Java applications."
      },
      {
        "type": "h2",
        "text": "1Ô∏è‚É£ **JVM (Java Virtual Machine):** The Runtime Engine"
      },
      {
        "type": "key_point",
        "text": "The JVM is an **abstract machine** that provides a runtime environment in which Java bytecode can be executed. It is the core reason Java is **Platform Independent** ('Write once, run anywhere')."
      },
      {
        "type": "list",
        "text": "It takes the compiled `.class` files (bytecode) and converts them into machine code for the specific operating system (Windows, macOS, Linux) in real-time."
      },
      {
        "type": "list",
        "text": "It handles essential runtime tasks like **memory management** (Garbage Collection) and **security**."
      },
      {
        "type": "h2",
        "text": "2Ô∏è‚É£ **JRE (Java Runtime Environment):** The Execution Package"
      },
      {
        "type": "key_point",
        "text": "The JRE is a physical package that contains the **JVM** and is required to **run** Java applications."
      },
      {
        "type": "list",
        "text": "It includes the JVM, plus libraries and other components needed to execute the code."
      },
      {
        "type": "h2",
        "text": "3Ô∏è‚É£ **JDK (Java Development Kit):** The Full Development Suite"
      },
      {
        "type": "key_point",
        "text": "The JDK is the largest package, containing the **JRE** plus the development tools (compilers, debuggers, etc.) necessary to **create** Java applications."
      },
      {
        "type": "list",
        "text": "If you only want to *run* a Java program, you need the JRE. If you want to *develop* Java programs, you need the JDK."
      },
      {
        "type": "h2",
        "text": "4Ô∏è‚É£ The `public static void main(String[] args)`"
      },
      {
        "type": "code_block",
        "text": "public static void main(String[] args) { ... }"
      },
      {
        "type": "key_insight",
        "text": "This is the **entry point** for any stand-alone Java application. The JVM looks for this exact signature to begin execution."
      },
      {
        "type": "conclusion",
        "text": "‚úÖ **Conclusion:** The Java Virtual Machine allows compiled Java bytecode to run across any operating system, ensuring maximum portability and stability."
      }
    ]
  }
]; // The closing bracket for the postsData array was the main syntax issue.

// Component to display a single blog post
const BlogPost = ({ post }) => {
    // Function to manually render <ul> for consecutive list items
    const renderContent = (content) => {
        const elements = [];
        let i = 0;
        while (i < content.length) {
            const item = content[i];
            if (item.type === 'list') {
                // Start a new <ul> for consecutive list items
                const listItems = [];
                let j = i;
                while (j < content.length && content[j].type === 'list') {
                    listItems.push(content[j]);
                    j++;
                }
                elements.push(
                    <ul key={i} className="space-y-2 pl-5">
                        {listItems.map((listItem, liIndex) => (
                            <ContentRenderer key={liIndex} contentItem={listItem} />
                        ))}
                    </ul>
                );
                i = j; // Move index past the processed list items
            } else {
                // Render non-list items directly
                elements.push(<ContentRenderer key={i} contentItem={item} />);
                i++;
            }
        }
        return elements;
    };

    // The BlogPost component renders the post title, date, and body
    return (
        <article className="py-8">
            <h1 className="text-2xl font-extrabold text-indigo-800 hover:text-indigo-600 transition-colors cursor-pointer">
                {post.title}
            </h1>
            <p className="text-sm text-gray-500 mb-4">{post.date}</p>
            <div className="space-y-4">
                {renderContent(post.content)}
            </div>
            <div className="mt-4 flex flex-wrap gap-2">
                {post.tags.map(tag => (
                    <span key={tag} className="inline-block bg-indigo-100 text-indigo-700 text-xs font-semibold px-2.5 py-0.5 rounded-full">
                        {tag}
                    </span>
                ))}
            </div>
        </article>
    );
};

// Component for the filter buttons
const FilterButton = ({ tag, filterTag, setFilterTag }) => {
    const isActive = tag === filterTag;
    const baseClasses = "text-base font-semibold py-2 px-4 rounded-full transition-all duration-200 focus:outline-none focus:ring-2 focus:ring-offset-2";
    const activeClasses = "bg-indigo-600 text-white shadow-lg ring-indigo-500 ring-2 ring-offset-2";
    const inactiveClasses = "bg-white text-gray-700 border border-gray-300 hover:bg-gray-100";

    // Map the button text based on the tag
    const buttonText = tag === 'All' ? 'All Concepts' : tag;

    return (
        <button
            onClick={() => setFilterTag(tag)}
            className={`${baseClasses} ${isActive ? activeClasses : inactiveClasses}`}
        >
            {buttonText}
        </button>
    );
};


// Main App Component
const App = () => {
    // Default filter is 'All'
    const [filterTag, setFilterTag] = useState('All');

    // Logic to filter posts based on the selected tag
    const filteredPosts = postsData.filter(post => {
        if (filterTag === 'All') {
            return true;
        }
        // Checks if the post's tags include the filterTag
        return post.tags.includes(filterTag);
    });

    const availableTags = ['All', ...new Set(postsData.flatMap(post => post.tags))];

    return (
        <div className="mx-auto max-w-7xl px-4 sm:px-6 lg:px-8">
            {/* Header/Title */}
            <header className="py-6 border-b border-indigo-200">
                <h1 className="text-4xl font-extrabold text-indigo-700 tracking-tight">My Learning Journal</h1>
            </header>

            <main className="py-12">
                {/* Tag Filter Buttons */}
                <div className="flex flex-wrap gap-3 mb-10">
                    {availableTags.map(tag => (
                        <FilterButton key={tag} tag={tag} filterTag={filterTag} setFilterTag={setFilterTag} />
                    ))}
                </div>

                {/* Heading adjusts based on filter */}
                <h2 className="text-4xl font-extrabold text-gray-800 mb-10 border-b-4 border-indigo-500 inline-block pb-1">
                    {filterTag === 'All' ? 'Latest Concepts' : `${filterTag} Concepts`}
                </h2>

                {/* List of Posts */}
                <div className="divide-y divide-gray-200">
                    {filteredPosts.length > 0 ? (
                        filteredPosts.map((post) => (
                            <BlogPost key={post.id} post={post} />
                        ))
                    ) : (
                        <p className="text-xl text-gray-500 italic mt-8">No posts found for the selected category. Try selecting 'All Concepts'.</p>
                    )}
                </div>
                
                {/* Footer */}
                <footer className="mt-12 text-center text-gray-500 text-sm py-4 border-t">
                    <p>&copy; 2025 Learning Journal. Built with React and Tailwind CSS.</p>
                </footer>
            </main>
        </div>
    );
};

// Render the App component
const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<App />);

    </script>
</body>
</html>
